#include<bits/stdc++.h>
using namespace std;
int n,k,cnt;
char c[10][10];
int dx[]={1,-1,0,0};
int dy[]={0,0,1,-1};
int vis[11][11];
void dfs(int x,int y,int ans){
    if(ans>=k){
        cnt++;
        return;
    }
    for(int i=0;i<4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!vis[nx][ny]&&c[nx][ny]=='#'){
            vis[nx][ny]=1;
            dfs(nx,ny,ans+1);
            vis[nx][ny]=0;
        }
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    while(1){
        cnt=0;
        cin>>n>>k;
        if(n==-1&&k==-1) break;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                cin>>c[i][j];
            }
        }
        if(c[1][1]=='#'){
            vis[1][1]=1;
            dfs(1,1,0);
            vis[1][1]=0;
        }
        cout<<cnt<<'\n';
        memset(vis,0,sizeof(vis));
    }
    return 0;
}
/*
# T714940 dfs-二维选和不选-1

## 题目描述

在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 $k$ 个棋子的所有可行的摆放方案 $C$。

`#` 表示可以放棋子的地方，`.` 表示不可以放棋子的地方。

## 输入格式

输入含有多组测试数据。

每组数据的第一行是两个正整数$n, k$，用一个空格隔开，表示了将在一个`n*n`的矩阵内描述棋盘，以及摆放棋子的数目。

## 输出格式

对于每一组数据，给出一行输出，输出摆放的方案数目$C$（数据保证$C<2^{31}$）。

## 输入输出样例 #1

### 输入 #1

```
1 1
.
8 1
..##.##.
........
...#.##.
#.#.####
.#....#.
.#.#.##.
....#...
#.......
6 5
..#.#.
...#..
.#....
..##..
##....
#.....
-1 -1
```

### 输出 #1

```
0
21
3
```

## 说明/提示

#### 数据范围

对于 $30\%$ 的数据：`#`的数量等于 $k$。  
对于另外 $30\%$ 的数据：只有`#`。   
对于 $100\%$ 的数据：$n ≤ 8 , k ≤ n$ 。
*/